<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Glibc | My code works, I don't know why.]]></title>
  <link href="http://wen00072.github.io/blog/categories/glibc/atom.xml" rel="self"/>
  <link href="http://wen00072.github.io/"/>
  <updated>2019-06-09T14:16:22+08:00</updated>
  <id>http://wen00072.github.io/</id>
  <author>
    <name><![CDATA[Wen Liao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[觀察編譯glibc的產出]]></title>
    <link href="http://wen00072.github.io/blog/2019/06/08/glibc-build-observing/"/>
    <updated>2019-06-08T18:48:03+08:00</updated>
    <id>http://wen00072.github.io/blog/2019/06/08/glibc-build-observing</id>
    <content type="html"><![CDATA[<p>這次介紹編譯glibc 並安裝後的一些發現</p>

<h2>目錄</h2>

<ul>
<li><a href="#glibc_env">測試環境</a></li>
<li><a href="#glibc_install">安裝步驟</a></li>
<li><a href="#glibc_conl">觀察與結論</a>

<ul>
<li><a href="#glibc_conl_lib">/lib</a></li>
<li><a href="#glibc_conl_bin">/bin</a></li>
<li><a href="#glibc_conl_sbin">/sbin</a></li>
<li><a href="#glibc_conl_etc">/etc</a></li>
<li><a href="#glibc_conl_share">/share</a></li>
<li><a href="#glibc_conl_var">/var</a></li>
<li><a href="#glibc_conl_libexec">/libexec</a></li>
<li><a href="#glibc_conl_inc">/include</a></li>
</ul>
</li>
<li><a href="#glibc_conl_ref">參考資料</a></li>
<li><a href="#glibc_conl_ex">附錄</a></li>
</ul>


<p><a name="glibc_env"></a></p>

<h2>測試環境</h2>

<pre><code>$ lsb_release -a
No LSB modules are available.
Distributor ID: Ubuntu
Description:    Ubuntu 18.04.2 LTS
Release:    18.04
Codename:   bionic
</code></pre>

<p><a name="glibc_install"></a></p>

<h2>安裝步驟</h2>

<ul>
<li>下載套件</li>
</ul>


<pre><code>git clone http://sourceware.org/git/glibc.git
cd glibc
git checkout --track origin/release/2.27
</code></pre>

<ul>
<li>在新的目錄編譯 glibc，你可以自行指定安裝路徑，<font color=red><strong>一定要指定安裝路徑，以免發生嚴重悲劇。</strong> </font></li>
</ul>


<p>本次設定主要是針對除錯最佳化，以及避免覆蓋系統原本的 <code>glibc</code></p>

<pre><code>cd ../
mkdir out
mkdir rootfs
cd out

# 設定
CFLAGS=-Og CPPFLAGS=-Og CXXFLAGS=-Og ../glibc/configure  --disable-werror --prefix=/tmp/rootfs/

# 編譯
make

# 安裝
make install
</code></pre>

<p><a name="glibc_conl"></a></p>

<h2>觀察與結論</h2>

<p>本來想說 <code>libc</code> 用來提供 C 標準函式庫的 binary，那麼了不起就是 <code>libc.so</code>和 <code>libc.a</code> 以及對應的 header files。安裝完畢後先看一下目錄，事情果然沒有像本組裝工想的那麼簡單。列出第一層目錄如下，除了預期中的<code>lib</code>和<code>include</code>以外，竟然還有不少預期以外的目錄。</p>

<pre><code>$ tree -L 1 -d /tmp/rootfs
.
├── bin
├── etc
├── include
├── lib
├── libexec
├── sbin
├── share
└── var
</code></pre>

<p>那麼我們來看一下這些目錄下面有什麼東西吧。</p>

<p><a name="glibc_conl_lib"></a></p>

<h3>/lib</h3>

<p>先來看目錄結構，多了和多國語言相關的函式庫目錄還有 trace shared object PLT (Procedure linkage table) 工具會用到的audio目錄</p>

<pre><code>$ tree lib -d
lib
├── audit
└── gconv
</code></pre>

<p>接下來看<code>/lib</code>的檔案</p>

<p>列出幾個我有興趣的檔案</p>

<ul>
<li><p><code>*.o</code></p>

<ul>
<li>在<code>/lib</code>裏面會發現幾個object file，它們檔名都有<code>crt</code>，crt全名是 <code>C runtime</code>，顯然和執行的時候有關。我有空會再找時間了解。先列出來介紹幾個如下</li>
</ul>
</li>
<li><p><code>Scrt1.o</code>: 這邊我們可以看到<code>T _start</code>以及<code>U main</code>，望文生義按圖說故事我們可以猜測執行程式的起始點其實是<code>_start</code>，做了一些事情後才會去呼叫你寫的<code>main()</code>，我做了一個實驗，想知道一個應用程式會連結哪些系統上的object檔案請參考<a href="#glibc_conl_ex">這邊</a></p></li>
</ul>


<pre><code>$ nm Scrt1.o 
0000000000000000 D __data_start
0000000000000000 W data_start
                 U _GLOBAL_OFFSET_TABLE_
0000000000000000 R _IO_stdin_used
                 U __libc_csu_fini
                 U __libc_csu_init
                 U __libc_start_main
                 U main
0000000000000000 T _start
</code></pre>

<ul>
<li><code>crtn.o</code>: 用<code>nm</code>去看會發現沒有<code>symbol</code>，不過反組譯後會發現有兩個<code>section</code>，看起來和main啟動前和使用者程式結束後會有關係。有空會再探討。</li>
</ul>


<pre><code>$ objdump -d crtn.o 

crtn.o:     file format elf64-x86-64


Disassembly of section .init:

0000000000000000 &lt;.init&gt;:
   0:   48 83 c4 08             add    $0x8,%rsp
   4:   c3                      retq   

Disassembly of section .fini:

0000000000000000 &lt;.fini&gt;:
   0:   48 83 c4 08             add    $0x8,%rsp
   4:   c3                      retq   
</code></pre>

<ul>
<li><code>ld-linux-x86_64.so.2</code>

<ul>
<li>就是<code>ld.so</code>，這個檔案有趣的點是他是一個shared object，但是同時又是可以執行。如果我的懶病沒有發作以後會常常看到這個東西。</li>
</ul>
</li>
<li><code>libc.*</code>:

<ul>
<li>直接看symbol就知道，<code>T</code>, <code>U</code>的定義請翻前面文章，我懶得找。</li>
</ul>
</li>
</ul>


<pre><code>$ nm libc.a | grep "^printf.o:" -A 10
printf.o:
0000000000000000 T _IO_printf
0000000000000000 T printf
0000000000000000 T __printf
                 U stdout
                 U __vfprintf_internal

snprintf.o:
0000000000000000 W snprintf
0000000000000000 T __snprintf
                 U __vsnprintf_internal    
</code></pre>

<ul>
<li><code>libm.*</code>: 一樣看symbol節錄</li>
</ul>


<pre><code>$ nm libm.so.6 |grep " sin"
000000000002eb24 i sin
0000000000034532 W sincos
00000000000419cc i sincosf
0000000000054f26 W sincosf128
00000000000419cc i sincosf32
0000000000034532 W sincosf32x
0000000000034532 W sincosf64
00000000000175c8 W sincosf64x
00000000000175c8 W sincosl
000000000004131e i sinf
0000000000054148 W sinf128
000000000004131e i sinf32
000000000002eb24 i sinf32x
000000000002eb24 i sinf64
0000000000016ead W sinf64x
000000000000ed11 W sinh
000000000001205d W sinhf
0000000000060407 W sinhf128
000000000001205d W sinhf32
000000000000ed11 W sinhf32x
000000000000ed11 W sinhf64
000000000000d9a4 W sinhf64x
000000000000d9a4 W sinhl
0000000000016ead W sinl
00000000000144b5 t sin_pi
0000000000027776 t sin_pi
</code></pre>

<ul>
<li><code>libdl</code>

<ul>
<li>動態載入函式庫相關函數如<code>dlvsym</code>, <code>dlsym</code>,</li>
</ul>
</li>
</ul>


<h4>完整檔案如下</h4>

<pre><code>$ ls lib
audit                         libc.a                 libmemusage.so              libnss_dns.so               librt-2.28.9000.so
crt1.o                        libc_nonshared.a       libm.so                     libnss_dns.so.2             librt.a
crti.o                        libcrypt-2.28.9000.so  libm.so.6                   libnss_files-2.28.9000.so   librt.so
crtn.o                        libcrypt.a             libmvec-2.28.9000.so        libnss_files.so             librt.so.1
gconv                         libcrypt.so            libmvec.a                   libnss_files.so.2           libSegFault.so
gcrt1.o                       libcrypt.so.1          libmvec_nonshared.a         libnss_hesiod-2.28.9000.so  libthread_db-1.0.so
ld-2.28.9000.so               libc.so                libmvec.so                  libnss_hesiod.so            libthread_db.so
ld-linux-x86-64.so.2          libc.so.6              libmvec.so.1                libnss_hesiod.so.2          libthread_db.so.1
libanl-2.28.9000.so           libdl-2.28.9000.so     libnsl-2.28.9000.so         libpcprofile.so             libutil-2.28.9000.so
libanl.a                      libdl.a                libnsl.so.1                 libpthread-2.28.9000.so     libutil.a
libanl.so                     libdl.so               libnss_compat-2.28.9000.so  libpthread.a                libutil.so
libanl.so.1                   libdl.so.2             libnss_compat.so            libpthread.so               libutil.so.1
libBrokenLocale-2.28.9000.so  libg.a                 libnss_compat.so.2          libpthread.so.0             Mcrt1.o
libBrokenLocale.a             libm-2.28.9000.a       libnss_db-2.28.9000.so      libresolv-2.28.9000.so      Scrt1.o
libBrokenLocale.so            libm-2.28.9000.so      libnss_db.so                libresolv.a
libBrokenLocale.so.1          libm.a                 libnss_db.so.2              libresolv.so
libc-2.28.9000.so             libmcheck.a            libnss_dns-2.28.9000.so     libresolv.so.2
</code></pre>

<p><a name="glibc_conl_bin"></a></p>

<h3>/bin</h3>

<p>是除了 <code>ldd</code>以外，我全部沒印象。有些甚至不在Ubuntu的預設安裝中。使用者需要另外安裝，如<code>xtrace</code>等。</p>

<p>列出幾個我有興趣的工具</p>

<ul>
<li><a href="http://man7.org/linux/man-pages/man1/pldd.1.html">pldd</a>: 列出process使用的shared library。奇怪的是我自己用卻只有列出process的執行檔名稱而已。</li>
<li><a href="http://manpages.org/sotruss">sotruss</a>: 經由PLT (Procedure Linkage Table) trace shared library calls</li>
<li><a href="http://manpages.org/sprof">sprof</a>: share object 的profile 工具</li>
</ul>


<pre><code>bin
├── catchsegv
├── gencat
├── getconf
├── getent
├── iconv
├── ldd
├── locale
├── localedef
├── makedb
├── mtrace
├── pcprofiledump
├── pldd
├── sotruss
├── sprof
├── tzselect
└── xtrace
</code></pre>

<p><a name="glibc_conl_sbin"></a></p>

<h3>/sbin</h3>

<ul>
<li>除了<code>ldconfig</code>外其他的不認識</li>
</ul>


<pre><code>$ tree sbin/
sbin/
├── iconvconfig
├── ldconfig
├── nscd
├── sln
├── zdump
etc
├── ld.so.conf
└── rpc
└── zic
</code></pre>

<p><a name="glibc_conl_etc"></a></p>

<h3>/etc</h3>

<p>很有趣，竟然有<code>rpc</code> (remote procedure call)的檔案，紀錄rpc通訊協定的資訊。</p>

<pre><code>etc
├── ld.so.conf
└── rpc
</code></pre>

<p><a name="glibc_conl_share"></a></p>

<h3>/share</h3>

<ul>
<li>存放時區以及多國語言相關檔案</li>
</ul>


<p><a name="glibc_conl_var"></a></p>

<h3>/var</h3>

<p>跳過</p>

<p><a name="glibc_conl_libexec"></a></p>

<h3>/libexec</h3>

<p>跳過</p>

<p><a name="glibc_conl_inc"></a></p>

<h3>/include</h3>

<p>跳過</p>

<p><a name="glibc_conl_ref"></a></p>

<h2>參考資料</h2>

<ul>
<li><a href="http://dbp-consulting.com/tutorials/debugging/linuxProgramStartup.html">Linux x86 Program Start Up</a></li>
<li><a href="http://l4u-00.jinr.ru/usoft/WWW/www_debian.org/Documentation/elf/elf.html">ELF: From The Programmer&rsquo;s Perspective: The .init and .fini Sections (1995)</a></li>
<li><a href="https://stackoverflow.com/questions/29694564/what-is-the-use-of-start-in-c">Stackoverflow: What is the use of _start() in C?</a></li>
<li><a href="https://stackoverflow.com/questions/32700494/executing-init-and-fini">Stackoverflow: Executing init and fini</a></li>
</ul>


<p><a name="glibc_conl_ex"></a></p>

<h2>附錄</h2>

<ul>
<li>編譯hello.c 囉唆資訊節錄</li>
</ul>


<pre><code>/usr/lib/gcc/x86_64-linux-gnu/7/collect2 -plugin /usr/lib/gcc/x86_64-linux-gnu/7/liblto_plugin.so -plugin-opt=/usr/lib/gcc/x86_64-linux-gnu/7/lto-wrapper -plugin-opt=-fresolution=/tmp/ccnUW8Qj.res -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lc -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s --sysroot=/ --build-id --eh-frame-hdr -m elf_x86_64 --hash-style=gnu --as-needed -dynamic-linker /lib64/ld-linux-x86-64.so.2 -pie -z now -z relro -o hello /usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/Scrt1.o /usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/crti.o /usr/lib/gcc/x86_64-linux-gnu/7/crtbeginS.o -L/usr/lib/gcc/x86_64-linux-gnu/7 -L/usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu -L/usr/lib/gcc/x86_64-linux-gnu/7/../../../../lib -L/lib/x86_64-linux-gnu -L/lib/../lib -L/usr/lib/x86_64-linux-gnu -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-linux-gnu/7/../../.. /tmp/ccTxSMPW.o -lgcc --push-state --as-needed -lgcc_s --pop-state -lc -lgcc --push-state --as-needed -lgcc_s --pop-state /usr/lib/gcc/x86_64-linux-gnu/7/crtendS.o /usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/crtn.o
</code></pre>

<ul>
<li>會連結系統提供的object檔案列出如下

<ul>
<li>crtn.o</li>
<li>Scrt1.o</li>
<li>crti.o</li>
<li>crtendS.o</li>
<li>crtbeginS.o</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在Ubuntu 18.04.2 Trace 程式呼叫 Glibc 函數]]></title>
    <link href="http://wen00072.github.io/blog/2019/06/08/glibc-surface-observing/"/>
    <updated>2019-06-08T15:39:12+08:00</updated>
    <id>http://wen00072.github.io/blog/2019/06/08/glibc-surface-observing</id>
    <content type="html"><![CDATA[<p>不囉唆，直接上懶人包。</p>

<h2>環境設定</h2>

<pre><code>#!/bin/bash
# 其實直接在剪下指令貼在終端機就就可以了
# 安裝套件並下載libcsource code
DBG_PATH=~/tmp/lib_debug
sudo apt install -y libc6-dbg
mkdir -p $DBG_PATH
cd $DBG_PATH
apt source libc6-dev
rm glibc_2.27-3ubuntu1.debian.tar.xz  glibc_2.27.orig.tar.xz glibc_2.27-3ubuntu1.dsc

# 設定load directory
LIBC_PATH=${DBG_PATH}/glibc-2.27
EX_FILES=~/tmp/lib_debug/ld_dir.ex
rm -f $EX_FILES
for i in $(find ${LIBC_PATH}/* -maxdepth 0 -type d); \
  do echo "directory $i" &gt;&gt; $EX_FILES ; 
done
</code></pre>

<h2>使用方式</h2>

<pre><code>gdb 你的執行檔 -x ~/tmp/lib_debug/ld_dir.ex
</code></pre>

<h2>範例</h2>

<h3>程式</h3>

<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
    printf("Hello world\n");

    return 0;
}
</code></pre>

<h3>示範操作</h3>

<pre><code>$ gdb ./hello -x ~/tmp/lib_debug/ld_dir.ex
GNU gdb (Ubuntu 8.1-0ubuntu3) 8.1.0.20180409-git
....
Reading symbols from ./hello...done.
(gdb) b main
Breakpoint 1 at 0x63e: file hello.c, line 5.
(gdb) r
Starting program: /tmp/hello 

Breakpoint 1, main () at hello.c:5
5       printf("Hello world\n");
(gdb) s
_IO_puts (str=0x5555555546e4 "Hello world") at ioputs.c:33
33  {
(gdb) 
</code></pre>

<h2>參考資料</h2>

<ul>
<li><a href="http://fcamel-life.blogspot.com/2012/01/glibc.html">fcamel 技術隨手記: 追踪 glibc 裡的程式</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
