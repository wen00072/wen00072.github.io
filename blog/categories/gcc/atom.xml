<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Gcc | My code works, I don't know why.]]></title>
  <link href="http://wen00072.github.io/blog/categories/gcc/atom.xml" rel="self"/>
  <link href="http://wen00072.github.io/"/>
  <updated>2018-12-12T21:44:50+08:00</updated>
  <id>http://wen00072.github.io/</id>
  <author>
    <name><![CDATA[Wen Liao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[關於GNU Inline Assembly]]></title>
    <link href="http://wen00072.github.io/blog/2015/12/10/about-inline-asm/"/>
    <updated>2015-12-10T22:16:49+08:00</updated>
    <id>http://wen00072.github.io/blog/2015/12/10/about-inline-asm</id>
    <content type="html"><![CDATA[<p>以前稍微接觸過GNU Inline Assembly，對於那些奇怪的符號總是覺得匪夷所思。這次找時間把他整理一下。雖然釐清了一些觀念，不過卻產生更多的疑惑，也許以後有機會看到範例會慢慢有感覺吧。</p>

<h2>目錄</h2>

<ul>
<li><a href="#ia-preface">前言</a></li>
<li><a href="#ia-env">測試環境</a></li>
<li><a href="#ia-syntax">語法</a>

<ul>
<li><a href="#ia-output">Output operands</a></li>
<li><a href="#ia-input">Input operands</a></li>
<li><a href="#ia-clo-reg">Clobbered registers list</a></li>
<li><a href="#ia-constr">Constraints</a></li>
</ul>
</li>
<li><a href="#ia-ref">參考資料</a></li>
</ul>


<p><a name="ia-preface"></a></p>

<h2>前言</h2>

<p>我自己對於GNU Inline Assembly的看法。</p>

<ul>
<li>編譯器 夠聰明，所以暫存器分配可以安心交給編譯器處理。也就是說語法上面要處理這塊。</li>
<li>暫存器、變數有些資訊仍然要讓編譯器知道，讓編譯器產生object binary遵守這樣的規則，如

<ul>
<li>這個operand是一個暫存器</li>
<li>這個operand是一塊記憶體</li>
<li>這個operand是浮點常數</li>
<li>&hellip;</li>
</ul>
</li>
<li>不想讓編譯器幫你安排暫存器，而是在Inline Assembly指定暫存器的話，就要明確的列出來。讓編譯器知道這些暫存器有被改過資料，進而針對這些暫存器做適當的處理。</li>
</ul>


<p><a name="ia-env"></a></p>

<h2>測試環境</h2>

<p>我使用ARMv7為主的Banana Pi開發版加上Lubuntu 14.04作為測試環境。</p>

<pre><code>$ lsb_release -a
No LSB modules are available.
Distributor ID: Ubuntu
Description:    Ubuntu 14.04.3 LTS
Release:    14.04
Codename:   trusty

$ dmesg
...
[    0.000000] Linux version 3.4.90 (bananapi@lemaker) (gcc version 4.6.3 (Ubuntu/Linaro 4.6.3-1ubuntu5) ) #2 SMP PREEMPT Tue Aug 5 14:11:40 CST 2014
[    0.000000] CPU: ARMv7 Processor [410fc074] revision 4 (ARMv7), cr=10c5387d
...

$ gcc -v
...
Target: arm-linux-gnueabihf
...
gcc version 4.8.4 (Ubuntu/Linaro 4.8.4-2ubuntu1~14.04) 
</code></pre>

<p><a name="ia-syntax"></a></p>

<h2>語法</h2>

<p>inline assembler關鍵字是<code>asm</code>，不過<code>__asm__</code>也可以使用(<a href="#ia_ps0">註</a>)。</p>

<p>根據目前(Dec/2015)的<a href="https://gcc.gnu.org/onlinedocs/gcc/index.html#Top">gcc手冊</a>，inline assembler有分為<code>basic</code>和<code>extended</code>兩種。雖然我使用的平台是gcc 4.8.4，而且gcc 4.8.5<a href="https://gcc.gnu.org/onlinedocs/gcc-4.8.5/gcc/index.html#Top">手冊</a>(官方網站上沒有4.8.4手冊)並沒有提到這個部份。但是目前<strong>語法上</strong>測試的確沒有問題，但是有些說明上面卻很難驗證是否可以套用到4.8.5上(例如最佳化的說明、需要注意常犯的錯誤)，請自行斟酌。</p>

<p>以下是整理自最新的手冊說明，請自行斟酌您使用的gcc版本是否有符合。</p>

<h3>Basic inline assembler</h3>

<pre><code class="c">     [ volatile ] asm("Assembler Template");
</code></pre>

<p>以下是整理自最新(Dec/2015)的手冊說明節錄，請自行斟酌您使用的gcc版本是否有符合。</p>

<ul>
<li>basic inline assembler 預設就是volatile</li>
<li>基本上編譯器只是把引號內的東西抄錄，所以只要組譯器支援的語法，就可以寫入Assembler Template內</li>
<li>和extended inline assembler的差異

<ul>
<li>extended inline assembler 只允許在函數內使用</li>
<li>有<code>naked</code>屬性的函數必須使用basic inline assembler(見<a href="#ia_ps1">註解</a>)</li>
<li>basic inline assembler就是把template內的字串作為組合語言組譯。而<code>%</code>字元在extended inline assembler有特別意義，然而有些組合語言如x86中<code>%</code>是暫存器語法的一部份。以至於<code>%</code>字元要在extended inline assembler中改為<code>%%</code>才是真正的意思，舉個例子<code>%eax</code>-><code>%%eax</code></li>
</ul>
</li>
<li>有要使用C 語言的資料，使用extended inline assembler比較妥當</li>
<li>GCC 最佳化時是有可能把你的inline assembler幹掉或是和你想的不一樣，請注意</li>
<li>你不可以從一個<code>asm(..)</code>裏面跳到另外一個<code>asm(..)</code>的label</li>
</ul>


<p>最簡單的<del>廢話</del>範例如下
<code>c
    asm("nop"); /* 啥事都不要做 */
</code></p>

<p>在沒有使用C 語言的變數下，就和一般的組合語言沒有差太多。
更複雜一點的例子可以看<a href="https://github.com/embedded2014/rtenv/blob/master/kernel.c#L10">rtenv</a>裏面的使用方式：</p>

<pre><code class="c">size_t strlen(const char *s) __attribute__ ((naked));
size_t strlen(const char *s)
{
    asm(
        "    sub  r3, r0, #1            \n"
        "strlen_loop:               \n"
        "    ldrb r2, [r3, #1]!        \n"
        "    cmp  r2, #0                \n"
        "   bne  strlen_loop        \n"
        "    sub  r0, r3, r0            \n"
        "    bx   lr                    \n"
        :::
    );
}
</code></pre>

<p>要注意<code>__attribute__ ((naked));</code>是有意義的。這是為何這段範例沒有直接指名用到C 語言函式變數名稱的關鍵點。有興趣請看<a href="https://gcc.gnu.org/onlinedocs/gcc/ARM-Function-Attributes.html#ARM-Function-Attributes">這邊</a>，請直接找字串<code>naked</code>。</p>

<h3>Extended inline assembler</h3>

<pre><code class="c">     asm [volatile] ( AssemblerTemplate
                        : OutputOperands   // optional
                      [ : InputOperands    // optional
                      [ : Clobbers ]       // optional
                      ])
</code></pre>

<p>Assembler Template基本上就是你要寫的組語加上 Inline Assembler 專用的符號。要注意的是，在編譯的過程中，你寫的inline assembler可能由於最佳化考慮不會被組譯。如果你確認你inline assembler一定要被組譯，請加上<code>volatile</code> keyword。</p>

<p>Assembler 專用的符號節錄如下：</p>

<table  style="width:100%">
    <tr>
        <th>符號</th>
        <th>說明</th>
    </tr>
    <tr>
        <td width=15%">%%</td>
        <td>單一%字元</td>
    </tr>
    <tr>
        <td>%{</td>
        <td>單一{字元</td>
    </tr>
    <tr>
        <td>%}</td>
        <td>單一}字元</td>
    </tr>
    <tr>
        <td>|{</td>
        <td>單一|字元</td>
    </tr>
    <tr>
        <td>%=</td>
        <td>只知道並驗證過會產生唯一的數字。用途部份看不懂，英文真是奧妙的東西啊。</td>
    </tr>
</table>


<p></p>

<p>AssemblerTemplate</p>

<p>由於<a href="#ia-preface">前言</a>提到的三項個人猜測，造成inline assembler要使用C 語言變數時語法會出現很多令人眼花撩亂的符號。</p>

<p>由於編譯器提供協助分配暫存器和記憶體，也就是說需要有對應的語法指定目前指令的operand是什麼。GCC 有兩種方式指定，分別是</p>

<ul>
<li>編號指定，從零開始編號</li>
<li>Symbolic name指定: GCC 3.1以後支援<a href="https://gcc.gnu.org/onlinedocs/gcc-4.8.5/gcc/Extended-Asm.html#Extended-Asm">出處</a></li>
</ul>


<p>分別給個範例讓各位感受一下</p>

<h4>編號指定，從零開始編號</h4>

<p>這邊<code>%0</code>, <code>%1</code>就是編號。後面operand可以看到就是指定變數、以及變數的限制。這邊簡單解釋一下<code>=</code>表示這是一個輸出、而<code>r</code>表示變數要放在暫存器中、<code>m</code>表示變數是放在記憶體中。有興趣比對編譯出來的binary反組譯時的組合語言請看<a href="#ia_ps2">這邊</a>。不過編號和指令中的operand似乎很隨意，我沒有看到特殊規範。只能交叉比對assembler template和input/output operands才能看出端倪。我猜更複雜的情況你還要比對反組譯出來的結果。</p>

<pre><code class="c">#include &lt;stdio.h&gt;

int main(void)
{
    int var1 = 12;
    int var2 = 10;

    asm("mov %0, %1 \n  \
         add %1, %0, $1" : "=r"(var1), "=r"(var2) : "r"(var2), "r"(var1):);
    printf("var1 = %d, var2 = %d\n", var1, var2);

    asm("ldr r5, %0 \n":           : "m"(var1): "r5");
    asm("str r4, %0"   : "=m"(var2):          : "r4");
    return 0;
}
</code></pre>

<h4>Symbolic name指定</h4>

<p>編號的缺點就是可讀性比較差，所以gcc 3.1出現使用symbolic name的方式。至於那一個比較好，看你自己習慣。</p>

<p>直接把上面的範例更改一下。<a href="https://gcc.gnu.org/onlinedocs/gcc-4.8.5/gcc/Extended-Asm.html#Extended-Asm">GCC 4.8.5手冊</a>上面說symbolic name隨便取，甚至和變數同名稱都可以，<strong>只要單一asm(&hellip;)內的 symbolic name不要重複就好</strong>。有興趣比對編譯出來的binary反組譯時的組合語言請看<a href="#ia_ps3">這邊</a>。</p>

<pre><code class="c">#include &lt;stdio.h&gt;

int main(void)
{
    int var1 = 12;
    int var2 = 10;

    asm("mov %[my_var1], %[my_var2] \n  \
         add %[my_var3], %[my_var4], $1" : 
            [my_var1] "=r" (var1), [my_var3] "=r" (var2) :
            [my_var2] "r"  (var2), [my_var4] "r"  (var1) :);
    printf("var1 = %d, var2 = %d\n", var1, var2);

    asm("ldr r5, %[my_var1] \n":: [my_var1] "m"(var1): "r5");
    asm("str r4, %[my_var1]": [my_var1] "=m" (var2):: "r4");
    return 0;
}
</code></pre>

<p>接下來來看每個欄位吧。</p>

<p><a name="ia-output"></a></p>

<h4>Output operands</h4>

<pre><code class="c">    [ [asmSymbolicName] ] constraint (cvariablename)
</code></pre>

<p><code>[asmSymbolicName]</code> 是GCC 3.1以後支援語法，如前所述，不用Symbolic Name就用編號方式對應assembler template operand。</p>

<p>指定結果要存在C 語言中的那個變數。要注意的除了要設定對的資訊（constraints，<a href="#ia-constr">下面</a>會節錄) 以外，operand的prefix一定要是<code>=</code>或<code>+</code>這兩個constraint。</p>

<p>隨便舉幾個範例</p>

<ul>
<li><code>=r(var1)</code>：變數請寫入並放在暫存器中</li>
<li><code>=m(var1)</code>：變數請寫入並存到記憶體中</li>
</ul>


<p><a name="ia-input"></a></p>

<h4>Input operands</h4>

<pre><code class="c">    [ [asmSymbolicName] ] constraint (cvariablename)
</code></pre>

<p><code>[asmSymbolicName]</code> 是GCC 3.1以後支援語法，如前所述，不用Symbolic Name就用編號方式對應assembler template operand。</p>

<p>指定要從在C 語言中的那個變數取出資料。主要是要設定對的資訊（constraints，<a href="#ia-constr">下面</a>會節錄) 。</p>

<ul>
<li><code>r(var1)</code>：變數請放在暫存器中</li>
<li><code>m(var1)</code>：變數是在記憶體中</li>
</ul>


<p><a name="ia-clo-reg"></a></p>

<h4>Clobbered registers list</h4>

<p>先講結論，在<code>asm("語法")</code>中明確地指定暫存器名稱的話，要在這邊列出。</p>

<p>現在我會習慣查單字。<code>Clobbered</code>查英文單字會發現就是把東西用力地砸毀。所以翻譯成中文就是「砸爛的暫存器列表」。什麼是爛掉的暫存器？就是本節前面的結論囉。</p>

<p>另外從Dec/2015的gcc 手冊還有找到下面<a href="https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html#Clobbers">語法</a>，一樣請注意版本問題</p>

<table  style="width:100%">
    <tr>
        <th>符號</th>
        <th>說明</th>
    </tr>
    <tr>
        <td width="15%">&#8220;cc&#8221;</td>
        <td>和狀態有關的flag暫存器會被修改</td>
    </tr>
    <tr>
        <td>&#8220;memory&#8221;</td>
        <td>這段組合語言會讀寫列出operand以外的記憶體內容，因此編譯器會視情況備份暫存器或讀寫記憶體</td>
    </tr>
</table>


<p><a name="ia-constr"></a></p>

<h3>Constraints</h3>

<pre><code class="c">&lt;Constraints&gt;       ::= &lt;Constraint Modifier&gt; &lt;Other Constraints&gt; | &lt;Other Constraints&gt;
&lt;Other Constraints&gt; ::= &lt;Simple Constraints&gt; | &lt;Machine Constraints&gt;

; /* 以上BNF是我整理的，terminal symbol請自行看手冊 */
</code></pre>

<p>節錄整理我<del>看得懂</del>感興趣的部份。</p>

<h5>Simple Constraints</h5>

<table  style="width:100%">
    <tr>
        <th>符號</th>
        <th>說明</th>
    </tr>
    <tr>
        <td width="15%">空白字元</td>
        <td>會被忽略，排版用</td>
    </tr>
    <tr>
        <td>m</td>
        <td>operand 存放在記憶體中</td>
    </tr>
    <tr>
        <td>r</td>
        <td>operand 將被放在暫存器中</td>
    </tr>
    <tr>
        <td>i</td>
        <td>operand 是一個整數常數，該常數包含下面的情形(symbolic name)：`#define MAX_LINE (32)`</td>
    </tr>
    <tr>
        <td>n</td>
        <td>operand 是一個整數常數，只允許填入數字</td>
    </tr>
    <tr>
        <td>E</td>
        <td>operand 是一個浮點數常數，不清楚和`F`的差異</td>
    </tr>
    <tr>
        <td>F</td>
        <td>operand 是一個浮點數常數，不清楚和`E`的差異</td>
    </tr>
    <tr>
        <td>g</td>
        <td>operand 存在暫存器(r)或是記憶體內(m)，或是這是一個整數常數</td>
    </tr>    
    <tr>
        <td>X</td>
        <td>不用檢查operand</td>
    </tr>
</table>


<p>　　</p>

<p>你可以使用組合技如<code>"rim"</code>，如果這樣寫的話，意思是要編譯器幫你挑一個最適合的方式處理對應於assembler template內的operand。
　　</p>

<h5>Constraint Modifier</h5>

<table  style="width:100%">
    <tr>
        <th>符號</th>
        <th>說明</th>
    </tr>
    <tr>
        <td width="15%">=</td>
        <td>表示這是一個write only的operand，必須為contraint開始字元。</td>
    </tr>
    <tr>
        <td>+</td>
        <td>表示這個 operand 在指令中是同時被讀寫的，必須為contraint開始字元。</td>
    </tr>
    <tr>
        <td>&</td>
        <td>該operand 為earlyclobber。earlyclobber就是在instruction讀取該operand前，該operand會被寫入。雖然如此，到底是多久前？是和data hazard有關嘛？還是跟資料一致性有關？或者是和編譯器 最佳化造成非預期結果有關？真是一團謎<font color="red">完全搞不懂做啥用，也不清楚使用時機。</font><a href="http://lxr.free-electrons.com/source/arch/arm/include/asm/uaccess.h#L364">這邊有範例</a>，一樣搞不懂為什麼要有+, &的modifier</td>
    </tr>
    <tr>
        <td>%</td>
        <td>該operand 可以讓編譯器 決定這個operand是否和後面的operand交換(commutative)，<font color="red">完全搞不懂做啥用</font></td>
    </tr>
</table>


<p>　　</p>

<h5>ARM 專用的Constraint</h5>

<p>我參考的是gcc 4.8.5手冊(因為和測試環境的gcc版本最接近)，可能有版本的問題，這些我都沒有做實驗測試，請自行斟酌。</p>

<table  style="width:100%">
    <tr>
        <th>符號</th>
        <th>說明(一般模式)</th>
    </tr>
    <tr>
        <td width="20%">w</td>
        <td width="80%">VFP 浮點運算</td>
    </tr>
    <tr>
        <td>G</td>
        <td>浮點運算的0.0</td>
    </tr>
    <tr>
        <td>I</td>
        <td>8 bit正整數</td>
    </tr>
    <tr>
        <td>K</td>
        <td>I contraint 的invert (一的補數)，Wen: 不知道為什麼要扯到I constraint？</td>
    </tr>
    <tr>
        <td>L</td>
        <td>I contraint 的負數 (二的補數)，Wen: 不知道為什麼要扯到I constraint？</td>
    </tr>
    <tr>
        <td>M</td>
        <td>0 ~ 32的正整數</td>
    </tr>
    <tr>
        <td>Q</td>
        <td>要參考的記憶體位址存放在一個暫存器內</td>
    </tr>
    <tr>
        <td>R</td>
        <td>operand是一個const pool內的東西，不要問我const pool是啥，估狗到都和Java有關</td>
    </tr>
    <tr>
        <td>S</td>
        <td>operand 目前檔案中.text內的一個symbol</td>
    </tr>
    <tr>
        <td>Uv</td>
        <td>VFP load/store 指令可存取的記憶體</td>
    </tr>
    <tr>
        <td>Uy</td>
        <td>iWMMXt load/store 指令可存取的記憶體</td>
    </tr>
    <tr>
        <td>Uq</td>
        <td>ARMv4 ldrsb 指令可存取的記憶體</td>
    </tr>
</table>


<p></p>

<p>完整列表在這邊，要注意的是2015年12月的手冊又多了一些新的contstraint。請自行參考。</p>

<ul>
<li><a href="https://gcc.gnu.org/onlinedocs/gcc-4.8.5/gcc/Machine-Constraints.html#Machine-Constraints">gcc 4.8.5: Constraints for Particular Machines</a>

<ul>
<li>請自行參考你的硬體平台</li>
</ul>
</li>
<li><a href="https://gcc.gnu.org/onlinedocs/gcc/Machine-Constraints.html#Machine-Constraints">Dec/2015手冊: 6.44.4.4 Constraints for Particular Machines</a></li>
</ul>


<p><a name="ia-ref"></a></p>

<h2>參考資料</h2>

<ul>
<li>中文

<ul>
<li><a href="http://www.study-area.org/cyril/opentools/opentools/x969.html">(BIG5)用Open Source工具開發軟體: 新軟體開發關念: Chapter 4. GNU Compiler Collection</a>

<ul>
<li>題外話，寫這位文件的作者個人非常佩服，但是網路上似乎關於這位作者只有這份文件。真是神祕的人物</li>
</ul>
</li>
<li><a href="http://nano-chicken.blogspot.tw/2010/12/inline-assembly.html">Nano雞排: Inline Assembly</a></li>
</ul>
</li>
<li>英文

<ul>
<li><a href="https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html#Using-Assembly-Language-with-C">gcc: How to Use Inline Assembly Language in C Code</a>

<ul>
<li><a href="https://gcc.gnu.org/onlinedocs/gcc/index.html#Top">手冊</a>上寫是給<code>gcc 6.0</code>，我目前從GGG release網站上看到<a href="https://gcc.gnu.org/releases.html">最新版本</a>是5.3，怪。</li>
<li>為什麼列出這個，因為我原本找的gcc-4.8.5 對於assembler template說明沒有特別列出gcc 支援的inline assembler符號。另外這份的文件結構的確比4.8.5清楚。</li>
</ul>
</li>
<li><a href="https://gcc.gnu.org/onlinedocs/gcc-4.8.5/gcc/Extended-Asm.html#Extended-Asm">gcc-4.8.5: Assembler Instructions with C Expression Operands</a></li>
<li><a href="https://gcc.gnu.org/onlinedocs/gcc-4.8.5/gcc/Constraints.html#Constraints">gcc-4.8.5: Constraints for asm Operands</a></li>
<li><a href="http://www.ethernut.de/en/documents/arm-inline-asm.html">ARM GCC Inline Assembler Cookbook</a>

<ul>
<li>相當推荐，不論是給的說明和範例，更厲害的是關於contraint部份寫的比手冊清楚，一樣我沒測過就是了。</li>
</ul>
</li>
<li><a href="http://ericw.ca/notes/a-tiny-guide-to-gcc-inline-assembly.html">A Tiny Guide to GCC Inline Assembly</a></li>
<li><a href="https://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html">GCC-Inline-Assembly-HOWTO</a></li>
<li><a href="http://wiki.osdev.org/Inline_Assembly">OSDev: Inline Assembly</a></li>
<li><a href="http://asm.sourceforge.net/articles/rmiyagi-inline-asm.txt">Introduction to GCC inline assembler</a>

<ul>
<li>似乎有點古老。</li>
</ul>
</li>
</ul>
</li>
</ul>


<h2>附錄</h2>

<p><a name="ia_ps0"></a></p>

<ul>
<li>C 語言標準有提到編譯器可以使用<code>asm</code> keyword，而且沒有定義語法。有興趣可以找<code>C11</code>、<code>C99</code>、<code>C89</code>的標準，直接搜尋<code>asm</code>就可以看到了。</li>
</ul>


<hr />

<p><a name="ia_ps1"></a></p>

<ul>
<li><code>naked</code>使用basic inline assembler和extended inline assembler比較</li>
</ul>


<p>下面兩個函數，<code>strcmp1</code>沒有任何extended inline assembler而<code>strcmp2</code>硬塞了一個下去：
&#8220;`c
int strcmp1(const char <em>a, const char </em>b) <strong>attribute</strong> ((naked));
int strcmp1(const char <em>a, const char </em>b)
{
    asm(
        &ldquo;strcmp_lop1:                \n&rdquo;
        &ldquo;   ldrb    r2, [r0],#1     \n&rdquo;
        &ldquo;   ldrb    r3, [r1],#1     \n&rdquo;
        &ldquo;   cmp     r2, #1          \n&rdquo;
        &ldquo;   it      hi              \n&rdquo;
        &ldquo;   cmphi   r2, r3          \n&rdquo;
        &ldquo;   beq     strcmp_lop1      \n&rdquo;
        &ldquo;    sub     r0, r2, r3      \n&rdquo;
        &ldquo;   bx      lr              \n&rdquo;
        :::
    );
}</p>

<p>int strcmp2(const char <em>a, const char </em>b) <strong>attribute</strong> ((naked));
int strcmp2(const char <em>a, const char </em>b)
{
        int i;
    asm(
        &ldquo;strcmp_lop2:                \n&rdquo;
        &ldquo;   ldrb    r2, [r0],#1     \n&rdquo;
        &ldquo;   ldrb    r3, [r1],#1     \n&rdquo;
        &ldquo;   cmp     r2, #1          \n&rdquo;
        &ldquo;   it      hi              \n&rdquo;
        &ldquo;   cmphi   r2, r3          \n&rdquo;
        &ldquo;   mov     %1, $1 \n&rdquo;
        &ldquo;   beq     strcmp_lop2      \n&rdquo;
        &ldquo;    sub     r0, r2, r3      \n&rdquo;
        &ldquo;   bx      lr              \n&rdquo;
        :&ldquo;=r&rdquo;(i)::
    );
}
&#8220;`</p>

<p>我們可以比較一下下面兩個函數最後編譯出來的指令，<code>strcmp2</code>顯然和我們預期的差很多。
&#8220;`c
000083f4 <strcmp1>:</p>

<p>int strcmp1(const char <em>a, const char </em>b) <strong>attribute</strong> ((naked));
int strcmp1(const char <em>a, const char </em>b)
{
    asm(
    83f4:   f810 2b01   ldrb.w  r2, [r0], #1
    83f8:   f811 3b01   ldrb.w  r3, [r1], #1
    83fc:   2a01        cmp r2, #1
    83fe:   bf88        it  hi
    8400:   429a        cmphi   r2, r3
    8402:   d0f7        beq.n   83f4 <strcmp1>
    8404:   eba2 0003   sub.w   r0, r2, r3
    8408:   4770        bx  lr
        &ldquo;   beq     strcmp_lop1      \n&rdquo;
        &ldquo;    sub     r0, r2, r3      \n&rdquo;
        &ldquo;   bx      lr              \n&rdquo;
        :::
    );
}
    840a:   4618        mov r0, r3</p>

<p>0000840c <strcmp2>:
        &ldquo;   beq     strcmp_lop2      \n&rdquo;
        &ldquo;    sub     r0, r2, r3      \n&rdquo;
        &ldquo;   bx      lr              \n&rdquo;
        :&ldquo;=r&rdquo;(i)::
    );
}</p>

<pre><code>---
&lt;a name="ia_ps2"&gt;&lt;/a&gt;

* 範例一的反組譯節錄
</code></pre>

<p>$ objdump -d -S asm
&hellip;
000083f4 <main>:</p>

<h1>include &lt;stdio.h></h1>

<p>int main(void)
{
&hellip;
    int var1 = 12;
    83fa:   230c        movs    r3, #12
    83fc:   603b        str r3, [r7, #0]</p>

<pre><code>int var2 = 10;
83fe:   230a        movs    r3, #10
8400:   607b        str r3, [r7, #4]

asm("mov %0, %1 \n  \
     add %1, %0, $1" : "=r"(var1), "=r"(var2) : "r"(var2), "r"(var1):);
8402:   687b        ldr r3, [r7, #4]
8404:   683a        ldr r2, [r7, #0]
8406:   461a        mov r2, r3
8408:   f102 0301   add.w   r3, r2, #1
840c:   603a        str r2, [r7, #0]
840e:   607b        str r3, [r7, #4]
</code></pre>

<p>&hellip;
    asm(&ldquo;ldr r5, %0 \n&rdquo;:           : &ldquo;m&rdquo;(var1): &ldquo;r5&rdquo;);
    8424:   683d        ldr r5, [r7, #0]</p>

<pre><code>asm("str r4, %0"   : "=m"(var2):          : "r4");
8426:   607c        str r4, [r7, #4]
</code></pre>

<p>&hellip;
}
&hellip;
&#8220;`</p>

<hr />

<p><a name="ia_ps3"></a></p>

<ul>
<li>範例二的反組譯節錄</li>
</ul>


<pre><code class="c">$ objdump -d -S asm
...
000083f4 &lt;main&gt;:
#include &lt;stdio.h&gt;

int main(void)
{
...
    int var1 = 12;
    83fa:   230c        movs    r3, #12
    83fc:   603b        str r3, [r7, #0]

    int var2 = 10;
    83fe:   230a        movs    r3, #10
    8400:   607b        str r3, [r7, #4]

    asm("mov %[my_var1], %[my_var2] \n  \
         add %[my_var3], %[my_var4], $1" : 
            [my_var1] "=r" (var1), [my_var3] "=r" (var2) :
            [my_var2] "r"  (var2), [my_var4] "r"  (var1) :);
    8402:   687b        ldr r3, [r7, #4]
    8404:   683a        ldr r2, [r7, #0]
    8406:   461a        mov r2, r3
    8408:   f102 0301   add.w   r3, r2, #1
    840c:   603a        str r2, [r7, #0]
    840e:   607b        str r3, [r7, #4]
...
    asm("ldr r5, %[my_var1] \n":: [my_var1] "m"(var1): "r5");
    8424:   683d        ldr r5, [r7, #0]

    asm("str r4, %[my_var1]": [my_var1] "=m" (var2):: "r4");
    8426:   607c        str r4, [r7, #4]
...
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GNU: The C Preprocessor 導讀]]></title>
    <link href="http://wen00072.github.io/blog/2013/10/13/talk-about-c-macros/"/>
    <updated>2013-10-13T05:13:00+08:00</updated>
    <id>http://wen00072.github.io/blog/2013/10/13/talk-about-c-macros</id>
    <content type="html"><![CDATA[<p>C語言的前置處理(CPP: C preprocessor)是個很有趣的題目，知道在對的時機使用他們絕對能夠對於開發軟體有巨大的幫助。以下是我閱讀<a href="http://gcc.gnu.org/onlinedocs/cpp/index.html">GNU: The C Preprocessor</a>的筆記。請注意這只是筆記，詳細資料請自行參考原本網頁。</p>

<p><a name="目錄"></a></p>

<h2>目錄</h2>

<ul>
<li><a href="#%E6%B8%AC%E8%A9%A6%E7%92%B0%E5%A2%83">測試環境</a></li>
<li><a href="#%E6%B8%AC%E8%A9%A6%E7%92%B0%E5%A2%83">概論</a></li>
<li><a href="#Header%20Files">Header Files</a></li>
<li><a href="#%E5%B7%A8%E9%9B%86">巨集</a></li>
<li><a href="#Preprocessor%20Output">Preprocessor Output</a></li>
<li><a href="#gcc%E5%92%8CCPP%E7%9B%B8%E9%97%9C%E7%9A%84%E5%8F%83%E6%95%B8">gcc和CPP相關的參數</a></li>
<li><a href="#%E5%8F%83%E8%80%83%E8%B3%87%E6%96%99">參考資料</a></li>
</ul>


<p><a name="測試環境"></a></p>

<h2>測試環境</h2>

<ul>
<li><p>Ubuntu 12.04</p></li>
<li><p><a href="#%E7%9B%AE%E9%8C%84">回目錄</a></p></li>
</ul>


<p><a name="概論"></a></p>

<h2>概論</h2>

<ul>
<li>Preprocesser: 輸入文字，產生更動過的文字x。產生出來文字會當作另外執行程式的輸入資料。 <a href="http://en.wikipedia.org/wiki/Preprocessor">出處</a></li>
<li>CNU C有自訂專用的Preprocessor指令，如果程式有移植性考量，gcc可以加入<code>-std=c90</code>, <code>-std=c99</code>或<code>-std=c11</code>參數檢查。全開就用<code>-pedantic</code>參數</li>
</ul>


<h3>編碼</h3>

<ul>
<li>Source character set

<ul>
<li>為gcc內部CPP處理的字元編碼</li>
<li>gcc 讀入原始碼後會以UTF-8同構的字元編碼處理程式碼，CPP處理時的文字輸出(如gcc -E)也是使用Source character set</li>
<li>可使用<code>-finput-charset=</code>參數指定source file 字元編碼</li>
</ul>
</li>
<li>Execution character set

<ul>
<li>CPP處理結束後會將結果轉換成指定的編碼，預設仍然是UTF8</li>
<li>後面看不懂，不想看</li>
</ul>
</li>
</ul>


<h3>初始行為</h3>

<ul>
<li>Load檔案到記憶體內。GCC 支援不同Line end 格式(LF, CR LF, CR)

<ul>
<li>標準C 最後一行沒有line end是未定義行為，GCC會跳出警告訊息</li>
</ul>
</li>
<li>處理trigraphs

<ul>
<li>史前遺跡，早期有些電腦沒有C需要的字元而使用trigraphs代替。如<code>??/</code> 代表 <code>\</code></li>
<li>需要gcc參數設定才會支援</li>
</ul>
</li>
<li>將\斷行的statemenet合併成一行</li>
<li>把註解換成空白字元</li>
</ul>


<h3>取Token</h3>

<ul>
<li>空白鍵為分隔空白的單位</li>
<li>由左至右順序取token <code>a+++++b</code> -> <code>a++ ++ +b</code>而不是<code>a++ + ++b</code></li>
<li>Preprocessor token分類

<ul>
<li>identifiers: 單純的C合法token 如keyword, 字母和數字的組合</li>
<li>preprocessing numbers: 一般來說就是數字</li>
<li>String literals: 兩個<code>"</code>中間包含的字串，包括<code>#include "test.h"</code></li>
<li>Punctuators: @ $ ` 以外ASCII的標點符號</li>
<li>other: 直接pass到preprocessr output，一般來說C compiler會把other token打槍。

<ul>
<li>Other chars:

<ul>
<li>@</li>
<li>$</li>
<li>`</li>
<li>不是NUL的control char</li>
<li>ASCII 0x7F–0xFF (因為要支援國際字元、未來會討論存廢)</li>
</ul>
</li>
<li>NUL在註解中會被忽略，一般程式碼則視為空白</li>
</ul>
</li>
</ul>
</li>
<li>基本上，preprocesser 輸出就是一個token</li>
</ul>


<pre><code class="c">#define MY() ddd
int main(void)
{
    int i,MY()__;
    return
}
</code></pre>

<p>展開後就是</p>

<pre><code class="c">## 1 "b.c"
## 1 "&lt;built-in&gt;"
## 1 "&lt;command-line&gt;"
## 1 "b.c"

int main(void)
{
    int i,ddd __;
    return
}
</code></pre>

<h3>Preprossessor 語法概要</h3>

<ul>
<li>包含指令(directives)和巨集(macros)</li>
<li>提供

<ul>
<li>include檔案</li>
<li>巨集展開</li>
<li>條件式編譯</li>
<li>行號控制：目前不是很懂，看起來是可以告訴compiler編譯intermediate時該statement是從哪個檔案的那一行過來的</li>
<li>compile時可以吐error或warning</li>
</ul>
</li>
<li><p>除了gcc內建的directives外，directives以<code>#</code>開頭，前後都可以有空白</p></li>
<li><p><a href="#%E7%9B%AE%E9%8C%84">回目錄</a></p></li>
</ul>


<p><a name="Header Files"></a></p>

<h2>Header Files</h2>

<ul>
<li>Header file就是檔案，該檔案包含下面的元件，讓不同原始碼檔案共用。

<ul>
<li>C declarations</li>
<li>巨集</li>
</ul>
</li>
<li>原始碼檔案透過#include去取用這些Header Files的資料</li>
<li><code>#include</code>效果和複製header file到原始碼檔案一樣。你可以用<code>gcc -E 原始碼檔名</code>看到header file被放入。之所以這樣做就是讓使用者省去複製和多次修改相同介面的時間。</li>
</ul>


<h3>#include語法</h3>

<ul>
<li><code>#include &lt;file&gt;</code>

<ul>
<li>使用系統內建的標頭檔。標頭檔除了放在預設的目錄外，還可以在GCC下使用<code>-I</code>參數指定標頭檔路徑</li>
</ul>
</li>
<li><code>#include "file"</code>

<ul>
<li>自己原始碼專用的標頭檔。GCC搜尋順序

<ul>
<li>同一份原始檔的目錄</li>
<li><code>-iquote</code>指定的目錄</li>
<li><code>-I</code>指定的目錄</li>
</ul>
</li>
</ul>
</li>
</ul>


<h2>標頭擋路徑</h2>

<ul>
<li><code>echo | gcc -v -x c -E -</code>可以列出gcc 搜尋標頭檔目錄</li>
<li>gcc搜尋標頭檔順序是

<ul>
<li>系統預設路徑</li>
<li><code>-I</code>參數，一個以上<code>-I</code>路徑則由左至右開始搜尋</li>
</ul>
</li>
<li>可以使用<code>-nostdinc</code>讓gcc不去搜尋系統標準的include path</li>
</ul>


<h2>避免因為多重#include重複定義</h2>

<ul>
<li>狀況說明

<ul>
<li>原始碼檔案中include &ldquo;file1&#8221;和&#8221;file2&rdquo;</li>
<li>&ldquo;file2&#8221;也有include &#8220;file1&rdquo;</li>
<li>最後變成原始碼檔案中放了兩份file1的內容，一方面多餘另一方面也會發生重複定義的情況</li>
</ul>
</li>
<li>建議方式: <a href="http://en.wikipedia.org/wiki/Include_guard">Include guard</a></li>
</ul>


<pre><code class="c Include guard example">#ifndef MY_HEADER_H
#define MY_HEADER_H

#define MY_VAR (1)

#endif /* MY_HEADER_H */
</code></pre>

<h2>Computed Includes</h2>

<ul>
<li>用來節省太多條件式#include如</li>
</ul>


<pre><code class="c 條件式include">#ifdef LINUX
    #include &lt;linux_plat.h&gt;
#else
    #include &lt;windows_plat.h&gt;
#endif
</code></pre>

<ul>
<li>使用方式</li>
</ul>


<pre><code class="c C檔案">#include MY_DEF_H
</code></pre>

<pre><code class="makefile Makefile">CFLAGS=-DMY_DEF_H="&lt;linux_plat.h&gt;"
</code></pre>

<h2>System Headers</h2>

<ul>
<li><p>GCC會忽略掉系統標頭檔的Warning，如果其他一般標頭檔想要有相同的處理方式，可以使用<code>-isystem 路徑</code>讓GCC將該目錄下的標頭檔視為系統標頭導</p></li>
<li><p><a href="#%E7%9B%AE%E9%8C%84">回目錄</a></p></li>
</ul>


<p><a name="巨集"></a></p>

<h2>巨集</h2>

<ul>
<li>Marco分成

<ul>
<li>擬函數巨集: <code>#define foo()</code>: 重點是()，()前面不得有空格

<ul>
<li>定義完後可以直接當作function使用，所以可以玩<code>callback = foo;</code>這樣的描述</li>
</ul>
</li>
<li>資料相關巨集</li>
</ul>
</li>
</ul>


<h3>擬函數巨集</h3>

<ul>
<li>擬函數巨集可以吃參數，以<code>,</code>分開。所以<code>MAC(buf[x = 1, u + 1])</code>這樣的程式碼會被拆成兩個參數，請使用<code>MAC((buf[x = 1, u + 1]))</code></li>
<li>擬函數巨集的參數可以空白，多個參數請用<code>,</code>隔開。</li>
</ul>


<pre><code class="c 擬函數巨集參數空白範例">#define MY_MAC(x,y) my_mac(x,y)
...
MY_MAC(,);
MY_MAC(a,b);
MY_MAC(a,);
MY_MAC(,b);
</code></pre>

<ul>
<li>擬函數巨集定義的描述如果有使用<code>"</code>並且和參數相同，最後並不會被替換。

<ul>
<li><code>FOO(X) _bar(x, "x");</code> -> <code>FOO(bar) _bar(bar, "x");</code></li>
</ul>
</li>
</ul>


<h3>字串轉換</h3>

<pre><code class="c">#define ENCLOSE_QUOTE(VAR) #VAR
</code></pre>

<ul>
<li><code>ENCLOSE_QUOTE(test);</code> -> <code>"test"</code></li>
</ul>


<pre><code class="c">#define PLAY 0
#define ENCLOSE_QUOTE(VAR) #VAR
#define TO_STR(VAR) ENCLOSE_QUOTE(VAR)
</code></pre>

<ul>
<li><code>ENCLOSE_QUOTE(PLAY);</code> -> <code>"PLAY"</code></li>
<li><code>TO_STR(PLAY)</code> -> <code>ENCLOSE_QUOTE(0)</code> -> <code>"0"</code>

<ul>
<li>利用擬函數巨集展開參數的特性</li>
</ul>
</li>
</ul>


<h3>合體</h3>

<p><code>echo -e "#define  MYDEF(PARAM1, PARAM2)  PARAM1##PARAM2 \n\n MYDEF(xxx, yyy)" | gcc -E -x c -</code></p>

<h3>Variadic Macros:  兩種方式，不能一個巨集同時使用</h3>

<ul>
<li>C99語法：<code>#define my_printf(...) printf("myprintf: " __VA_ARGS__)</code></li>
<li>GNU語法：<code>#define my_printf(arg...) printf("myprintf: " args)</code></li>
<li>可以在varidic marco中明確指定參數

<ul>
<li><code>#define my_printf(format, ...) fprintf(stderr, format, __VA_ARGS__)</code>

<ul>
<li>缺點: 使用<code>my_printf("test");</code>會GG，因為被轉成<code>fprintf(stderr, "test",);</code></li>
<li>解法: <code>#define my_printf(format, ...) fprintf(stderr, format, ##__VA_ARGS__)</code>

<ul>
<li>GNU會把<code>,</code> 硬食掉</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>


<h3>GNU C支援的predefined Macros (節錄)</h3>

<h4>標準Macro: 可以望文生義就不解釋了</h4>

<ul>
<li><code>__FILE__</code></li>
<li><code>__LINE__</code></li>
<li><code>__func__</code>

<ul>
<li>GCC也有一樣功能的<code>__FUNCTION__</code></li>
</ul>
</li>
<li><code>__DATE__</code></li>
<li><code>__TIME__</code></li>
<li><code>__STDC__</code>：顯示目前是否使用Standard C編譯程式碼</li>
<li><code>__STDC_VERSION__</code>：Standard C版本</li>
<li><code>__cplusplus</code>：是否為C++編譯環境</li>
<li><code>__OBJC__</code>：是否為object C編譯環境</li>
<li><code>__ASSEMBLER__</code>：是否在組合語言環境</li>
</ul>


<h4>GNU Marco</h4>

<ul>
<li><code>__COUNTER__</code>：回傳一個從0開始的數字，每次呼叫一次加一</li>
<li>GCC版本

<ul>
<li><code>__VERSION__</code></li>
<li>細部版號

<ul>
<li><code>__GNUC__</code></li>
<li><code>__GNUC_MINOR__</code></li>
<li><code>__GNUC_PATCHLEVEL__</code></li>
</ul>
</li>
</ul>
</li>
<li><code>__GNUG__</code>：是否是用GNU C++</li>
<li><code>__INCLUDE_LEVEL__</code>：標頭檔被引用的深度，從0開始算。如a->b->c，c就是2</li>
<li><code>__ELF__</code>：輸出格式是否為elf</li>
<li><code>__TIMESTAMP__</code></li>
</ul>


<h3>系統內建Macro</h3>

<ul>
<li>和平台有關，使用下面指令查詢：<code>echo "" | gcc -x c -E -dM -</code></li>
<li>C標準規範使用<code>__</code>包夾或是<code>_</code>+<code>大寫</code>為系統內建Macro，其name space保留。</li>
</ul>


<h3>Undefine/Redefine</h3>

<pre><code class="c Undefine/Redefine範例">#define FOO BAR
...
#undef FOO
#define FOO BAR2
</code></pre>

<h3>密技和怪招</h3>

<h4>Misnesting</h4>

<ul>
<li>間接呼叫</li>
</ul>


<pre><code class="c 間接呼叫範例">#define MY_PRT(X) printf(x)
#define P_TEST(M) M("test")
...
P_TEST(MY_PRT);
</code></pre>

<ul>
<li>不對稱的括號</li>
</ul>


<pre><code class="c 不對稱的括號範例">#define TEST(x) func1(x, "test"
...
test(my_param));
</code></pre>

<ul>
<li>硬食分號</li>
</ul>


<pre><code class="c test.c">#define MY_TEST(x) { printf("test\n"); }
...
    if (bit)
        MY_TEST(bit);
    else
        printf("else\n");
</code></pre>

<p>編譯會錯誤，原因是因為分號會讓gcc判斷if statement已經結束</p>

<pre><code class="text 錯誤訊息">cc     test.c   -o test
test.c: In function ‘main’:
test.c:23:5: error: ‘else’ without a previous ‘if’
make: *** [test] Error 1
</code></pre>

<ul>
<li>解法: <code>do {...} while (0)</code></li>
</ul>


<pre><code class="c test.c">#define MY_TEST(x) do { printf("test\n"); } while(0)
...
    if (bit)
        MY_TEST(bit);
    else
        printf("else\n");
</code></pre>

<ul>
<li><p>除非明確了解巨集內容，否則避免直接傳函數進去巨集。<code>MY_TEST(func(xy,xx), 10));</code></p>

<ul>
<li>原因是巨集內也許會呼叫參數好幾次，如果傳進去的函數執行成本很高，就會發生悲劇。</li>
</ul>
</li>
<li><p><a href="#%E7%9B%AE%E9%8C%84">回目錄</a></p></li>
</ul>


<p><a name="Preprocessor Output"></a></p>

<h2>Preprocessor Output</h2>

<ul>
<li>可以使用<code>gcc -E 檔案</code>或是<code>cpp 檔案</code>觀察CPP的展開，和CPP相關格式請參考<a href="http://gcc.gnu.org/onlinedocs/cpp/Preprocessor-Output.html#Preprocessor-Output">這邊</a>。</li>
<li><a href="#%E7%9B%AE%E9%8C%84">回目錄</a></li>
</ul>


<p><a name="gcc和CPP相關的參數"></a></p>

<h2>gcc和CPP相關的參數</h2>

<ul>
<li>大部分選項和參數可以以空白隔開(<code>-I /usr/include</code>)或是直接連在一起(<code>-I/usr/include</code>)</li>
</ul>


<h3>節錄</h3>

<ul>
<li><code>-D 文字</code>: 定義<code>文字</code>巨集為1

<ul>
<li>測試<code>echo "TEST" | gcc -E -xc -DTEST -</code></li>
</ul>
</li>
<li><code>-D 文字=文字</code>：定義<code>文字</code>巨集

<ul>
<li>測試<code>echo "TEST" | gcc -E -xc -DTEST=CPP -</code></li>
</ul>
</li>
<li><code>-U</code>: undefine 巨集，如果參數同時有<code>-U</code>和<code>-D</code>的話優先先出現的先做</li>
<li><code>-I dir</code>:指定搜尋header file目錄

<ul>
<li><code>dir</code>以<code>=</code>開頭，gcc會取代成sysroot路徑，參考<code>--sysroot</code>和<code>-isysroot</code></li>
</ul>
</li>
<li><code>-M</code>:列出要檔案要吃的source code和header files

<ul>
<li>測試:</li>
</ul>
</li>
</ul>


<pre><code class="makefile -M範例">$ gcc -M b.c
b.o: b.c /usr/lib/gcc/x86_64-linux-gnu/4.6/include/stdint.h \
 /usr/include/stdint.h /usr/include/features.h \
 /usr/include/x86_64-linux-gnu/bits/predefs.h \
 /usr/include/x86_64-linux-gnu/sys/cdefs.h \
 /usr/include/x86_64-linux-gnu/bits/wordsize.h \
 /usr/include/x86_64-linux-gnu/gnu/stubs.h \
 /usr/include/x86_64-linux-gnu/gnu/stubs-64.h \
 /usr/include/x86_64-linux-gnu/bits/wchar.h /usr/include/stdio.h \
 /usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h \
 /usr/include/x86_64-linux-gnu/bits/types.h \
 /usr/include/x86_64-linux-gnu/bits/typesizes.h /usr/include/libio.h \
 /usr/include/_G_config.h /usr/include/wchar.h \
 /usr/lib/gcc/x86_64-linux-gnu/4.6/include/stdarg.h \
 /usr/include/x86_64-linux-gnu/bits/stdio_lim.h \
 /usr/include/x86_64-linux-gnu/bits/sys_errlist.h b.h
</code></pre>

<ul>
<li><code>-MM</code>:列出要檔案要吃的source code和非系統的header files</li>
</ul>


<pre><code class="text 範例">$ gcc -MM b.c
b.o: b.c b.h
</code></pre>

<ul>
<li><code>-MF file</code>:配合<code>-M</code>, <code>-MM</code>時將結果寫入<code>file</code></li>
<li><code>-MG</code>: <code>-M</code>, <code>-MM</code>parse到header file不存在會跳錯誤，而加上<code>-MG</code>後會假裝他們存在，照樣吐出結果。</li>
</ul>


<pre><code class="text -MG範例">$ mv b.h a
$ gcc   -MM b.c
b.c:3:15: fatal error: b.h: No such file or directory
compilation terminated.
$ gcc -MG  -MM b.c
b.o: b.c b.h
</code></pre>

<ul>
<li><code>-MP</code>: 順便把depend的target加入</li>
</ul>


<pre><code class="text -MP範例 ">$ gcc -MP -MM b.c
b.o: b.c b.h

b.h:
</code></pre>

<ul>
<li><code>-MT</code> :指定target</li>
</ul>


<pre><code class="text -MT範例 ">$ gcc -MT test -MM b.c
test: b.c b.h
</code></pre>

<ul>
<li><code>-MD</code>: 直接編譯，同時把會吃的檔案和header files放在*.d檔</li>
</ul>


<pre><code class="text -MD範例">$ rm a.out
$ gcc -MD b.c
$ ls a.out
a.out
$ cat b.d
b.o: b.c /usr/lib/gcc/x86_64-linux-gnu/4.6/include/stdint.h \
 /usr/include/stdint.h /usr/include/features.h \
 /usr/include/x86_64-linux-gnu/bits/predefs.h \
 /usr/include/x86_64-linux-gnu/sys/cdefs.h \
 /usr/include/x86_64-linux-gnu/bits/wordsize.h \
 /usr/include/x86_64-linux-gnu/gnu/stubs.h \
 /usr/include/x86_64-linux-gnu/gnu/stubs-64.h \
 /usr/include/x86_64-linux-gnu/bits/wchar.h /usr/include/stdio.h \
 /usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h \
 /usr/include/x86_64-linux-gnu/bits/types.h \
 /usr/include/x86_64-linux-gnu/bits/typesizes.h /usr/include/libio.h \
 /usr/include/_G_config.h /usr/include/wchar.h \
 /usr/lib/gcc/x86_64-linux-gnu/4.6/include/stdarg.h \
 /usr/include/x86_64-linux-gnu/bits/stdio_lim.h \
 /usr/include/x86_64-linux-gnu/bits/sys_errlist.h b.h
</code></pre>

<ul>
<li><code>-MMD</code>: 直接編譯，同時把會吃的檔案和非系統header files放在*.d檔</li>
</ul>


<pre><code class="text -MMD範例">$ rm a.out
$ gcc -MMD b.c
$ ls a.out
a.out
$ cat b.d
b.o: b.c b.h
</code></pre>

<ul>
<li><code>-dM</code>: 列出編譯時所有的巨集，不列出展開巨集的結果, 通常配合<code>-E</code></li>
<li><code>-dD</code>: 列出編譯時不包含predefine的巨集以及展開巨集的結果, 通常配合<code>-E</code></li>
<li><code>-dN</code>: 和<code>-dD</code>的差別是巨集只列出名稱不列出要展開的內容, 通常配合<code>-E</code>

<ul>
<li><code>#define foo bar</code> <code>-dD</code>輸出 <code>#define foo bar</code>，<code>-dN</code>結果 <code>#define foo</code></li>
</ul>
</li>
<li><code>-dI</code>:不顯是巨集，而是顯示<code>#include</code>的指令</li>
<li><code>-C</code>: 保留註解，不包含巨集展開的部份註解</li>
<li><code>-CC</code>: 保留註解，包含巨集展開的部份註解</li>
<li><p><code>-H</code>:列出編譯時會參考的header files</p></li>
<li><p><a href="#%E7%9B%AE%E9%8C%84">回目錄</a></p></li>
</ul>


<p><a name="參考資料"></a></p>

<h2>參考資料</h2>

<ul>
<li><a href="http://gcc.gnu.org/onlinedocs/cpp/index.html">GNU: The C Preprocessor</a></li>
<li>測試檔案</li>
</ul>


<pre><code class="c b.c ">#include &lt;stdint.h&gt;
#include &lt;stdio.h&gt;
#include "b.h"


#define foo  (bit,lfsr) /* XXX */
#define bar(x) lose(x)
#define lose(x) (1 + (x))

#if aaa
#define ddd ddds
#endif

int main(void)
{
    uint16_t lfsr = time(0);
    unsigned bit;
    unsigned period = 0;
    int c= 644;

    printf("%s\n", __BASE_FILE__);
    printf("%s\n", __VERSION__);
    if (bit)
        MY_TEST(bit);
    else
        MY_TEST(bit);
        printf("%d\n", (lfsr,bit,c));
        printf("%d\n", (bit, lfsr));

#line 10
printf("test:%d, %s\n", __LINE__, __FILE__); 

#if 0
    lfsr = typeof(bit) 10;
#endif

    bar(foo);
printf("test:%d, %s\n", __LINE__, __FILE__); 

    return 0;
}
</code></pre>

<pre><code class="c b.h">#define MY_TEST(x) do { printf("test\n"); } while(0)
</code></pre>

<ul>
<li><a href="#%E7%9B%AE%E9%8C%84">回目錄</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
